<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[集合面试]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2F%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[集合面试集合分为单列集合和双列集合 单列集合单列集合的顶级接口是Collection,下面有两个接口List和Set，List接口下集合的特点是有序，可重复； Set接口下集合：无序，不可重复 双列集合 集合总结图 面试题1. 集合的线程安全安全的集合有Vector和HashTable, 线程不安全ArrayList、HashSet、HashMap可以通过Collections类方法转化成线程安全的集合，其实就是在方法上加synchronized 1234561. // Collections.synchronizedCollection(c)2. // Collections.synchronizedList(list)3. // Collections.synchronizedMap(m)4. // Collections.synchronizedSet(s) List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(list1); 2. 并发集合按时并发集合 是jdk5.0重要的特性，增加了并发包java.util.concurrent.*。Java内存模型、volatile变量及AbstractQueuedSynchronizer(简称AQS同步器)，是并发包众多实现的基础。 常见的并发集合： ConcurrentHashMap：线程安全的HashMap的实现CopyOnWriteArrayList：线程安全且在读操作时无锁的ArrayListCopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素ArrayBlockingQueue：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue CopyOnWrite集合即写时复制的集合。 通俗的理解是当我们往一个集合添加元素的时候，不直接往当前集合添加，而是先将当前集合进行Copy，复制出一个新的集合，然后新的集合里添加元素，添加完元素之后，再将原集合的引用指向新的集合。这样做的好处是我们可以对CopyOnWrite集合进行并发的读，而不需要加锁，因为当前集合不会添加任何元素。所以CopyOnWrite集合也是一种读写分离的思想，读和写不同的集合。 Synchronized vs Concurrent Collections 不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在性能和可扩展性，还有他们如何实现的线程安全。同步HashMap, Hashtable, HashSet, Vector, ArrayList 相比他们并发的实现（比如：ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet）会慢得多。造成如此慢的主要原因是锁， 同步集合会把整个Map或List锁起来，而并发集合不会。并发集合实现线程安全是通过使用先进的和成熟的技术像锁剥离。比如ConcurrentHashMap 会把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。锁仅用于 put 和 remove 等改变集合对象的操作，基于 volatile 及 HashEntry 链表的不变性实现了读取的不加锁。 这些方式使得 ConcurrentHashMap 能够保持极好的并发支持， 尤其是对于读远比插入和删除频繁的 Map而言， 同样的，CopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个List复制一个副本给它。 如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。 3. List 的三个子类的特点 ArrayList 底层结构是数组,查询快,增删慢。如果只是用add方法的话，速度也可以，因为是在数组最后追加或删除元素，只会因为数组长度不够扩容影响速度。但是如果不是在最后追加或删除的话，插入元素后面的元素索引都会改变，速度慢。因为有索引，查找快。 LinkedList 底层结构是双向链表,增删快,查询慢。在LinkedList集合中的每个人都是随便站的。但是他们中的每个人都认识一个人。并且每两个认识的人之间都有一个链子把他们连接起来。所有人都连接完之后，顺着链子看，就也有一个顺序，每个人就也有一个序号，但是这个序号并没有标出来。也就是说相当于有一个隐式的序号。所以：比如我要叫4号出来的时候，他们并不知道自己到底谁是4号，所以就要顺着链子从头开始查一下，查到4号是谁了，4号就出来了。也就是说，每次要找n号位置的人时，都要从头查一遍，看谁是n号。所以查找比较麻烦。至于增删效率高，就很容易理解了。 indexof 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647LinkedList&lt;Integer&gt; integerLinkedList = new LinkedList&lt;&gt;(); integerLinkedList.add(1); integerLinkedList.add(2); integerLinkedList.add(3); integerLinkedList.add(4); Integer i = integerLinkedList.indexOf(2);//元素为2的索引 integerLinkedList.get(1);//取到索引为1的元素 System.out.println(i);public int indexOf(Object o) &#123; int index = 0;//索引是自己从链的头开始计数的 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; voctor 底层结构是数组 线程安全的,增删慢,查询慢。 2. 字符串去重排序12345678910111213141516171819202122232425262728//字符串去重并排序public static String RdSort(String str)&#123; String[] strs = str.split(""); TreeSet&lt;String&gt; stringTreeSet = new TreeSet&lt;&gt;();//使用TreeSet元素排序并去重的原理 for (String s : strs) &#123; stringTreeSet.add(s); &#125; System.out.println(stringTreeSet); String stryes=""; for (String s : stringTreeSet) &#123; stryes+=s; &#125; return stryes; &#125;//字符串去重并保持原来顺序public static String rd(String str)&#123; String[] strs = str.split(""); LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();//利用LinkedHashSet for (String s : strs) &#123; linkedHashSet.add(s); &#125; System.out.println(linkedHashSet); String stryes=""; for (String s : linkedHashSet) &#123; stryes+=s; &#125; return stryes; &#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试，集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合面试]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[集合面试集合分为单列集合和双列集合 单列集合单列集合的顶级接口是Collection,下面有两个接口List和Set，List接口下集合的特点是有序，可重复； Set接口下集合：无序，不可重复 双列集合 集合总结图 面试题1. 集合的线程安全安全的集合有Vector和HashTable, 线程不安全ArrayList、HashSet、HashMap可以通过Collections类方法转化成线程安全的集合，其实就是在方法上加synchronized 1234561. // Collections.synchronizedCollection(c)2. // Collections.synchronizedList(list)3. // Collections.synchronizedMap(m)4. // Collections.synchronizedSet(s) List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(list1); 2. 并发集合按时并发集合 是jdk5.0重要的特性，增加了并发包java.util.concurrent.*。Java内存模型、volatile变量及AbstractQueuedSynchronizer(简称AQS同步器)，是并发包众多实现的基础。 常见的并发集合： ConcurrentHashMap：线程安全的HashMap的实现CopyOnWriteArrayList：线程安全且在读操作时无锁的ArrayListCopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素ArrayBlockingQueue：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue CopyOnWrite集合即写时复制的集合。 通俗的理解是当我们往一个集合添加元素的时候，不直接往当前集合添加，而是先将当前集合进行Copy，复制出一个新的集合，然后新的集合里添加元素，添加完元素之后，再将原集合的引用指向新的集合。这样做的好处是我们可以对CopyOnWrite集合进行并发的读，而不需要加锁，因为当前集合不会添加任何元素。所以CopyOnWrite集合也是一种读写分离的思想，读和写不同的集合。 Synchronized vs Concurrent Collections 不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在性能和可扩展性，还有他们如何实现的线程安全。同步HashMap, Hashtable, HashSet, Vector, ArrayList 相比他们并发的实现（比如：ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet）会慢得多。造成如此慢的主要原因是锁， 同步集合会把整个Map或List锁起来，而并发集合不会。并发集合实现线程安全是通过使用先进的和成熟的技术像锁剥离。比如ConcurrentHashMap 会把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。锁仅用于 put 和 remove 等改变集合对象的操作，基于 volatile 及 HashEntry 链表的不变性实现了读取的不加锁。 这些方式使得 ConcurrentHashMap 能够保持极好的并发支持， 尤其是对于读远比插入和删除频繁的 Map而言， 同样的，CopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个List复制一个副本给它。 如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。 3. List 的三个子类的特点 ArrayList 底层结构是数组,查询快,增删慢。如果只是用add方法的话，速度也可以，因为是在数组最后追加或删除元素，只会因为数组长度不够扩容影响速度。但是如果不是在最后追加或删除的话，插入元素后面的元素索引都会改变，速度慢。因为有索引，查找快。 LinkedList 底层结构是双向链表,增删快,查询慢。在LinkedList集合中的每个人都是随便站的。但是他们中的每个人都认识一个人。并且每两个认识的人之间都有一个链子把他们连接起来。所有人都连接完之后，顺着链子看，就也有一个顺序，每个人就也有一个序号，但是这个序号并没有标出来。也就是说相当于有一个隐式的序号。所以：比如我要叫4号出来的时候，他们并不知道自己到底谁是4号，所以就要顺着链子从头开始查一下，查到4号是谁了，4号就出来了。也就是说，每次要找n号位置的人时，都要从头查一遍，看谁是n号。所以查找比较麻烦。至于增删效率高，就很容易理解了。 indexof 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647LinkedList&lt;Integer&gt; integerLinkedList = new LinkedList&lt;&gt;(); integerLinkedList.add(1); integerLinkedList.add(2); integerLinkedList.add(3); integerLinkedList.add(4); Integer i = integerLinkedList.indexOf(2);//元素为2的索引 integerLinkedList.get(1);//取到索引为1的元素 System.out.println(i);public int indexOf(Object o) &#123; int index = 0;//索引是自己从链的头开始计数的 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; voctor 底层结构是数组 线程安全的,增删慢,查询慢。 2. 字符串去重排序12345678910111213141516171819202122232425262728//字符串去重并排序public static String RdSort(String str)&#123; String[] strs = str.split(""); TreeSet&lt;String&gt; stringTreeSet = new TreeSet&lt;&gt;();//使用TreeSet元素排序并去重的原理 for (String s : strs) &#123; stringTreeSet.add(s); &#125; System.out.println(stringTreeSet); String stryes=""; for (String s : stringTreeSet) &#123; stryes+=s; &#125; return stryes; &#125;//字符串去重并保持原来顺序public static String rd(String str)&#123; String[] strs = str.split(""); LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();//利用LinkedHashSet for (String s : strs) &#123; linkedHashSet.add(s); &#125; System.out.println(linkedHashSet); String stryes=""; for (String s : linkedHashSet) &#123; stryes+=s; &#125; return stryes; &#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，hexo]]></title>
    <url>%2F%E5%82%BB%E9%80%BC%2F%E4%BD%A0%E5%A5%BD%EF%BC%8Chexo%2F</url>
    <content type="text"><![CDATA[这是个备份测试]]></content>
      <categories>
        <category>傻逼</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2Ftest%2F</url>
    <content type="text"><![CDATA[安抚都告诉]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[0]]></title>
    <url>%2F%E7%8B%97%E4%BB%94%2F0%2F</url>
    <content type="text"><![CDATA[阿凡达]]></content>
      <categories>
        <category>狗仔</category>
      </categories>
      <tags>
        <tag>发的发生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pei]]></title>
    <url>%2Funcategorized%2Fpei%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>zheshoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pictest]]></title>
    <url>%2Funcategorized%2Fpictest%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>方</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[abd]]></title>
    <url>%2Funcategorized%2Fabd%2F</url>
    <content type="text"><![CDATA[的高发个分]]></content>
      <tags>
        <tag>这是一个测试发多少</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_my_site]]></title>
    <url>%2Funcategorized%2Ftest-my-site%2F</url>
    <content type="text"></content>
  </entry>
</search>
