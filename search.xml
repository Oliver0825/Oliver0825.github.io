<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jenkins持续集成]]></title>
    <url>%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2Fjenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[jenkins持续集成Jenkins持续集成 它是一个自动化的周期性的集成测试过程 保证团队开发人员提交代码的质量，减轻了软件发布时的压力]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot打包与微服务部署]]></title>
    <url>%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2Fspringboot%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[springboot打包与微服务部署微服务部署有两种方法： （1）手动部署：首先基于源码打包生成jar包（或war包）,将jar包（或war包）上传至虚拟机并拷贝至JDK容器。 （2）通过Maven插件自动部署。（常用，和手动部署原理一致） 1. 手动部署1. 将源码打包生成jar包SpringBoot打包 pom.xml添加 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- Spring Boot的启动类--&gt; &lt;mainClass&gt;com.tensquare.eureka.EurekaApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 在启动类添加 extends SpringBootServletInitializer 在启动类中重写配置@Override protected SpringApplicationBuilder configure( SpringApplicationBuilder builder) { return builder.sources(this.getClass()); } clean, package java -jar 打成包的文件名(因为Windows配置了jdk的环境变量，在Windows直接就可以跑起来了，在docker中，需要在jdk镜像基础上打包微服务镜像，下面是在docker中部署微服务的步骤) 2. 使用脚本创建jdk镜像步骤： （1）创建目录 1mkdir –p /usr/local/java （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/java目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t=&apos;jdk1.8&apos; . （5）查看镜像是否建立完成 1docker images （6）创建容器 1docker run -it --name=myjdk8 jdk1.8 /bin/bash 3. 使用Dockerfile在jdk镜像上创建微服务镜像123456789101112131415# 基于哪个镜像FROM java:8# 将本地文件夹挂载到当前容器VOLUME /tmp# 拷贝文件到容器，也可以直接写成ADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar /app.jarADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar app.jarRUN bash -c &apos;touch /app.jar&apos;# 开放8761端口EXPOSE 8761# 配置容器启动后执行的命令ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 4. 将微服务镜像run成容器即可2. 通过Maven插件自动部署Maven插件自动部署步骤： （1）修改宿主机的docker配置，让其可以远程访问1vi /lib/systemd/system/docker.service 其中ExecStart=后添加配置-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock （2）刷新配置，重启服务123456#刷新配置systemctl daemon-reload#重启dockersystemctl restart docker#重启私有仓库docker start registry （3）在tensquare_eureka工程pom.xml 增加配置12345678910111213141516171819202122232425262728 &lt;build&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- docker的maven插件，官网：https://github.com/spotify/docker-maven-plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;192.168.184.135:5000/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt; &lt;baseImage&gt;jdk1.8&lt;/baseImage&gt; &lt;entryPoint&gt;["java", "-jar", "/$&#123;project.build.finalName&#125;.jar"]&lt;/entryPoint&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;dockerHost&gt;http://192.168.184.135:2375&lt;/dockerHost&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 以上配置会自动生成Dockerfile 123FROM jdk1.8ADD app.jar /ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] （4）在windows的命令提示符下，进入tensquare_eureka工程所在的目录，输入以下命令，进行打包和上传镜像1234mvn clean package docker:build -DpushImage#跳过测试-DskipTests]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合面试]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2F%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[集合面试集合分为单列集合和双列集合 单列集合单列集合的顶级接口是Collection,下面有两个接口List和Set，List接口下集合的特点是有序，可重复； Set接口下集合：无序，不可重复 双列集合 集合总结图 面试题1. 集合的线程安全安全的集合有Vector和HashTable, 线程不安全ArrayList、HashSet、HashMap可以通过Collections类方法转化成线程安全的集合，其实就是在方法上加synchronized 1234561. // Collections.synchronizedCollection(c)2. // Collections.synchronizedList(list)3. // Collections.synchronizedMap(m)4. // Collections.synchronizedSet(s) List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(list1); 2. 并发集合按时并发集合 是jdk5.0重要的特性，增加了并发包java.util.concurrent.*。Java内存模型、volatile变量及AbstractQueuedSynchronizer(简称AQS同步器)，是并发包众多实现的基础。 常见的并发集合： ConcurrentHashMap：线程安全的HashMap的实现CopyOnWriteArrayList：线程安全且在读操作时无锁的ArrayListCopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素ArrayBlockingQueue：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue CopyOnWrite集合即写时复制的集合。 通俗的理解是当我们往一个集合添加元素的时候，不直接往当前集合添加，而是先将当前集合进行Copy，复制出一个新的集合，然后新的集合里添加元素，添加完元素之后，再将原集合的引用指向新的集合。这样做的好处是我们可以对CopyOnWrite集合进行并发的读，而不需要加锁，因为当前集合不会添加任何元素。所以CopyOnWrite集合也是一种读写分离的思想，读和写不同的集合。 Synchronized vs Concurrent Collections 不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在性能和可扩展性，还有他们如何实现的线程安全。同步HashMap, Hashtable, HashSet, Vector, ArrayList 相比他们并发的实现（比如：ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet）会慢得多。造成如此慢的主要原因是锁， 同步集合会把整个Map或List锁起来，而并发集合不会。并发集合实现线程安全是通过使用先进的和成熟的技术像锁剥离。比如ConcurrentHashMap 会把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。锁仅用于 put 和 remove 等改变集合对象的操作，基于 volatile 及 HashEntry 链表的不变性实现了读取的不加锁。 这些方式使得 ConcurrentHashMap 能够保持极好的并发支持， 尤其是对于读远比插入和删除频繁的 Map而言， 同样的，CopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个List复制一个副本给它。 如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。 3. List 的三个子类的特点复杂度有时间复杂度和空间复杂度： 一个有 1000 个元素的 LinkedList 对象将有 1000 个链接在一起 的 Entry 对象； ArrayList 使用一个内置的数组来存 储元素，这个数组的起始容量是 10.当数组需要增长时，容量大概会增长 50%。 这就意味着，如果你有一个包含大量元素的 ArrayList 对象，那么最终将有很大的空间会被浪费掉，如果我们知道一个 ArrayList 将会有多少个元素，我们可以通过构造方法来指定容量。我们还可以通过 trimToSize 方法在 ArrayList 分配完毕之后去掉浪 费掉的空间。 总结：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList 会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用 LinkedList 了。 ArrayList 底层结构是数组,查询快,增删慢。如果只是用add方法的话，速度也可以，因为是在数组最后追加或删除元素，只会因为数组长度不够扩容影响速度。但是如果不是在最后追加或删除的话，插入元素后面的元素索引都会改变，速度慢。因为有索引，查找快。 LinkedList 底层结构是双向链表,增删快,查询慢。在LinkedList集合中的每个人都是随便站的。但是他们中的每个人都认识一个人。并且每两个认识的人之间都有一个链子把他们连接起来。所有人都连接完之后，顺着链子看，就也有一个顺序，每个人就也有一个序号，但是这个序号并没有标出来。也就是说相当于有一个隐式的序号。所以：比如我要叫4号出来的时候，他们并不知道自己到底谁是4号，所以就要顺着链子从头开始查一下，查到4号是谁了，4号就出来了。也就是说，每次要找n号位置的人时，都要从头查一遍，看谁是n号。所以查找比较麻烦。至于增删效率高，就很容易理解了。 indexof 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647LinkedList&lt;Integer&gt; integerLinkedList = new LinkedList&lt;&gt;(); integerLinkedList.add(1); integerLinkedList.add(2); integerLinkedList.add(3); integerLinkedList.add(4); Integer i = integerLinkedList.indexOf(2);//元素为2的索引 integerLinkedList.get(1);//取到索引为1的元素 System.out.println(i);public int indexOf(Object o) &#123; int index = 0;//索引是自己从链的头开始计数的 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; voctor 底层结构是数组 线程安全的,增删慢,查询慢。 4. Collections集合工具类 java.utils.Collections是集合工具类，操作的对象是集合。部分方法使用如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往传入集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list):随机置换,即可以打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序,整数从小到大排序 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; c):将集合中元素按照指定规则排序。 123456789101112List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("cba"); list.add("aba"); list.add("sba"); list.add("nba"); Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.charAt(0)-o1.charAt(0);//o2--o1降序；o1--o2升序 &#125; &#125;); System.out.println(list); 简述Comparable可比较接口和Comparator比较器接口的区别说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候再去选择的java.util.Comparator接口完成。 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用 Comparable：类内部实现比较器,默认规则 Comparator: 外比较器,类的外部自己写规则 //记忆,不管是内比较器还是外比较器,只要排序都要实现这两个接口之一, 如果两个接口都实现,优先考虑的外比较器Comparator 5. 为什么要用 List list = new ArrayList() ,而不用 ArrayList alist = new ArrayList()呢？多态的好处： 问题就在于List有多个实现类，现在你用的是ArrayList，也许哪一天你需要换成其它的实现类，如 LinkedList或者Vector等等，这时你只要改变这一行就行了： List list = new LinkedList(); 其它使用了list地方的代码根本不需要改动。 假设你开始用 ArrayList alist = new ArrayList(), 这下你有的改了，特别是如果你使用了 ArrayList特有的方法和属性。 List a=new ArrayList()和 ArrayList a =new ArrayList()的区别？ List list = new ArrayList();这句创建了一个 ArrayList 的对象后把上溯到了 List。此时它是一个 List 对象了，有些ArrayList 有但是 List 没有的属性和方法，它就不能再用了。而 ArrayList list=new ArrayList();创建一对象则保留了ArrayList 的所有属性。 所以需要用到 ArrayList 独有的方法的时候不能用前者。实例代码如下： 12341．List list = new ArrayList();2．ArrayList arrayList = new ArrayList();3．list.trimToSize(); //错误，没有该方法。4．arrayList.trimToSize(); //ArrayList 里有该方法。 2. 字符串去重排序12345678910111213141516171819202122232425262728//字符串去重并排序public static String RdSort(String str)&#123; String[] strs = str.split(""); TreeSet&lt;String&gt; stringTreeSet = new TreeSet&lt;&gt;();//使用TreeSet元素排序并去重的原理 for (String s : strs) &#123; stringTreeSet.add(s); &#125; System.out.println(stringTreeSet); String stryes=""; for (String s : stringTreeSet) &#123; stryes+=s; &#125; return stryes; &#125;//字符串去重并保持原来顺序public static String rd(String str)&#123; String[] strs = str.split(""); LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();//利用LinkedHashSet for (String s : strs) &#123; linkedHashSet.add(s); &#125; System.out.println(linkedHashSet); String stryes=""; for (String s : linkedHashSet) &#123; stryes+=s; &#125; return stryes; &#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试，集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，hexo]]></title>
    <url>%2F%E5%82%BB%E9%80%BC%2F%E4%BD%A0%E5%A5%BD%EF%BC%8Chexo%2F</url>
    <content type="text"><![CDATA[这是个备份测试]]></content>
      <categories>
        <category>傻逼</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2Ftest%2F</url>
    <content type="text"><![CDATA[安抚都告诉]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[0]]></title>
    <url>%2F%E7%8B%97%E4%BB%94%2F0%2F</url>
    <content type="text"><![CDATA[阿凡达]]></content>
      <categories>
        <category>狗仔</category>
      </categories>
      <tags>
        <tag>发的发生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pei]]></title>
    <url>%2Funcategorized%2Fpei%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>zheshoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pictest]]></title>
    <url>%2Funcategorized%2Fpictest%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>方</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[abd]]></title>
    <url>%2Funcategorized%2Fabd%2F</url>
    <content type="text"><![CDATA[的高发个分]]></content>
      <tags>
        <tag>这是一个测试发多少</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_my_site]]></title>
    <url>%2Funcategorized%2Ftest-my-site%2F</url>
    <content type="text"></content>
  </entry>
</search>
