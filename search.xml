<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2Flinux%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux常用命令1. 目录操作12345678910cd /aaacd ./cd ../cd ~pwd mkdir cp ‐r /aaa /bbb 将/目录下的aaa目录复制到/bbb目录下，在/bbb目录下名字为aaamv rm -rf r:迭代操作 f:force强制操作不提示find 位置 -name &quot;名称&quot; 2. 操作文件12345touch cat/more/less/tailvi/vimrm -fgrep &quot;搜索内容&quot; 文件名 --color 3. 压缩与解压 -c 创建新的文件（必选项） -x 取出文件中的内容（必选项） -f 文件名由命令台设置（必选项） -v 输出文件清单（可选项） -z 自动识别压缩或解压（可选项） 12tar -zxvftar -zcvf 4. 查看1234567891011tail -f 实时查看日志文件 tail -f 日志文件logtail - 100f 实时查看日志文件 后一百行tail -f -n 100 catalina.out linux查看日志后100行搜寻字符串grep ‘搜寻字符串’ filename按ctrl+c 退出]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaweb]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2FJavaweb%2F</url>
    <content type="text"><![CDATA[Javaweb1. JDBC1.1 原生 jdbc 操作数据库流程JDBC四个核心对象 这几个类都是在java.sql包中 DriverManager: 用于注册驱动、以及获取Connection连接对象 Connection: 表示与数据库创建的连接 Statement: 执行SQL语句的对象、将SQL语句发送到mysql服务器进行执行。 ResultSet: 结果集或一张虚拟表，查询数据的时候查询到的所有结果全部在ResultSet对象中 第一步：Class.forName()加载数据库连接驱动；第二步：DriverManager.getConnection()获取数据连接对象;第三步：根据 SQL 获取 sql 会话对象，有 2 种方式 Statement、PreparedStatement ;第四步：执行 SQL 处理结果集，执行 SQL 前如果有参数值就设置参数值 setXXX();第五步：关闭结果集、关闭会话、关闭连接。 1.2 使用PreparedStatement的好处 prepareStatement会先将SQL语句发送给数据库预编译。如果是相同的SQL语句结构，只用传入不同的参数即可，减少SQL编译次数，提高效率 123Statement stmt = conn.createStatement();stmt.executeUpdate("INSERT INTO users VALUES (1, '张三', '123456');");//数据库编译一次stmt.executeUpdate("INSERT INTO users VALUES (2, '李四', '666666');");//数据库再编译一次 123456789101112131415String sql = "INSERT INTO users VALUES (?, ?, ?);";// 会先将SQL语句发送给数据库预编译。PreparedStatement会引用着预编译后的结果。PreparedStatement pstmt = conn.prepareStatement(sql);//进行预编译// 设置参数pstmt.setInt(1, 1);pstmt.setString(2, "张三");pstmt.setString(3, "123456");pstmt.executeUpdate();// 再次设置参数pstmt.setString(1, 2);pstmt.setInt(2, "李四");pstmt.setString(3, "66666");pstmt.executeUpdate(); 防止SQL注入，安全性更高 提高了程序的可读性 1.3 连接池1.3.1 连接池的原理 连接池在初始化的时候会默认存放n个连接对象并存放到一个容器(LinkedList)中 当需要连接的时候，如果连接池中有连接就直接从连接池中获取，如果连接池中没有则新创建连接，如果连接数大于最大连接数时，如果再有请求需要获取连接则将其添加到等待队列 对于新创建的连接，一般不会直接销毁，它将被放到连接池中等待重复使用,只有当空闲超时后被释放。 对于原本就在连接池中的连接对象，用完之后直接放回连接池中 连接池中的连接数在空闲时会逐渐趋近于最小连接数(核心连接数),连接池在满载时的连接数会接近最大连接数。 1.3.2 自定义连接池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import javax.sql.DataSource;import java.io.PrintWriter;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.LinkedList;import java.util.logging.Logger;public class MyDataSource implements DataSource&#123; //自定义连接池简单实现,实现DataSource连接池接口,搞一个集合存储连接对象,通过实现类构造方法给集合添加连接对象 private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;&gt;();//空,通过工具类得到连接对象添加到集合 public MyDataSource() &#123; //通过工具类得到连接对象添加到集合 for (int i = 1; i &lt;= 10; i++) &#123; Connection connection = JDBCUtils.getConnection();//旧的连接对象 //connection新的连接对象 //MyConnection my = new MyConnection(connection旧的连接对象,pool); MyConnection my = new MyConnection(connection,pool); pool.add(my);//my新的连接对象,类close&#123;pool.add(this);&#125; //this新的连接对象; &#125; System.out.println("创建了多少个连接对象:"+size()); &#125; @Override public Connection getConnection() throws SQLException &#123;//MyDataSource类对象. Connection connection = pool.removeFirst(); return connection;//connection新的连接对象 //从pool的头部拿连接 //如果池子中有连接，就直接从池子中取 /* Connection connection = null; if (pool.size() &gt; 0) &#123; connection = pool.removeFirst(); &#125;else &#123; //池子中没有连接了 //先等待，等待超时之后，就新创建连接 connection = JDBCUtils.getConnection(); &#125; return connection;*/ &#125; //封装一个方法,得到连接个数不必要 public int size() &#123; return pool.size(); &#125; @Override public Connection getConnection(String username, String password) throws SQLException &#123; return null; &#125; @Override public PrintWriter getLogWriter() throws SQLException &#123; return null; &#125; @Override public void setLogWriter(PrintWriter out) throws SQLException &#123; &#125; @Override public void setLoginTimeout(int seconds) throws SQLException &#123; &#125; @Override public int getLoginTimeout() throws SQLException &#123; return 0; &#125; @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException &#123; return null; &#125; @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException &#123; return null; &#125; @Override public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException &#123; return false; &#125; //自定义连接池简单实现,实现DataSource连接池接口,搞一个集合存储连接对象,通过实现类构造方法给集合添加连接对象&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyConnection implements Connection&#123; private Connection conn; private LinkedList&lt;Connection&gt; pool; public MyConnection(Connection conn,LinkedList&lt;Connection&gt; pool) &#123; this.conn = conn; this.pool = pool; &#125; public MyConnection(Connection conn) &#123; this.conn = conn; &#125; @Override public void close() throws SQLException &#123; //重写这个close()方法，让其在调用这个close()方法的时候，将当前这个调用的连接对象归还到池子中 pool.addLast(this); &#125; public MyConnection() &#123; &#125; @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException &#123; return null; &#125; @Override public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException &#123; return false; &#125; @Override public Statement createStatement() throws SQLException &#123; return conn.createStatement(); &#125; @Override public PreparedStatement prepareStatement(String sql) throws SQLException &#123; return conn.prepareStatement(sql); &#125; @Override public CallableStatement prepareCall(String sql) throws SQLException &#123; return conn.prepareCall(sql); &#125; ......除了close()方法之外，其它方法都用传入的connection对象实现&#125; 2. Http2.1 请求请求分为请求行，请求头，请求体（get没有） 2.1.1 请求行 本次请求的基本信息 格式：请求方式 请求资源 协议版本 例如：POST /day40/req HTTP/1.1 2.1.2 请求头 本次请求的附加信息 格式：一行一个键值对，一个键值对是一个请求头，一次请求可以有多个请求头 例如：Referer:http://localhost/day40 2.1.3 请求体 本次请求的正文内容，是表单提交的参数 格式：表单数据的提交格式 name=value&amp;name=value.... 例如：username=tom&amp;password=123 注意：并非任何时候都有请求体。 什么时候有请求体？ 必须是post提交 必须有带name属性的表单项 2.2 http 常见的状态码有哪些? 200 OK 客户端请求成功 301 redirect: 301 代表永久性转移(Permanently Moved） 302 redirect: 302 代表暂时性转移(Temporarily Moved )//尽量使用301重定向，302容易造成网站劫持 网站劫持：从网站A（网站比较烂）上做了一个302跳转到网站B（搜索排名很靠前），这时候有时搜索引擎会使用网站B的内容，但却收录了网站A的地址，这样在不知不觉间，网站B在为网站A作贡献，网站A的排名就靠前了。 ​ 301跳转对查找引擎是一种对照驯良的跳转编制，也是查找引擎能够遭遇的跳转编制，它告诉查找引擎，这个地址弃用了，永远转向一个新地址，可以转移新域名的权重。而302重定向很容易被搜索引擎误认为是利用多个域名指向同一网站，那么你的网站就会被封掉，罪名是“利用重复的内容来干扰Google搜索结果的网站排名”。 400 Bad Requst 请求有语法错误 401 Unauthorized 请求未经授权 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在，比如输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器暂时不能处理请求 2.3 重定向和请求转发2.3.1 重定向和请求转发的区别 请求转发只有1次请求，重定向发2次请求 请求转发地址栏不变，重定向地址栏会变 请求转发是服务端的跳转，重定向是浏览器的跳转 请求转发时，是在一次请求中，request域对象可以共享数据，可以传递数据给下一个资源；重定向不能传递数据给下一个资源 注意：如果有数据要传递给下一个资源，就要使用请求转发；否则使用重定向 2.3.2 请求转发和重定向API12request.getRequestDispatcher("/target").forward(request,response)response.sendRedirect(request.getContextPath()+"/target") 2.4 响应 2.4.1 API1void setStatus(int sc) 设置此响应行的状态代码 1void setHeader(String name,String value) 用给定名称和值设置响应头 1234//自动刷新操作，在3秒后跳转京东主页 response.setHeader("Refresh"," 3;url=http://www.jd.com"); //设置响应状态码 response.setStatus(200); 2.4.2 常见响应头 location 使用location响应头实现重定向跳转页面 123456//设置重定向响应头 // response.setHeader("location","http://www.taobao.com"); //设置状态码 //response.setStatus(302); //============上面代码的简化方式====================== response.sendRedirect("http://www.taobao.com"); Content-Type响应头向浏览器输出中文数据无乱码方案 12response.setContentType("text/html;charset=utf-8");response.getwriter().write("你好中文") 它的作用与传统上Windows上的文件扩展名相同。 content-disposition 通知浏览器以何种方式获取数据（直接解析数据（网页，图片文本），或者以附件方式（下载文件）） 1response.setHeader("Content-Disposition","attachment;filename=" + DownloadUtils.encodeFilename(request, filename)); 2.4.3 设置响应体 字符型响应体设置 123response.setContentType("text/html;charset=utf-8")PrintWriter writer = response.getWriter();writer.print("文本内容会显示到浏览器页面上") 字节型响应体 12345678910111213141516ServletContext context = this.getServletContext();//需求：把web文件夹里WEB-INF/files里的a.jpg，传递到客户端浏览器页面上显示出来//获取a.jpg的输入流InputStream is = context.getResourceAsStream("WEB-INF/files/a.jpg");//得到一个输出流ServletOutputStream os = response.getOutputStream();//把数据写到输出流里int len = -1;byte[] buffer = new byte[1024];while ((len = is.read(buffer)) != -1) &#123; os.write(buffer, 0, len);&#125;//关闭流is.close();os.close(); 3. Servlet3.1 Servlet定义Server Applet，运行在服务端的Java程序，是sun公司提供的一套规范（接口）。用来处理客户端请求、响应给浏览器的动态资源，客户端在浏览器上通过url地址的形式，远程调用服务端的Servlet（Java程序）；Servlet就可以接收客户端的请求，向客户端发送响应。 3.2 Servlet的生命周期3.2.1 何时创建 默认第一次访问Servlet时，执行init方法，创建Servlet对象 init方法只执行一次 3.2.2 何时销毁 服务器关闭时或者把web项目取消部署时，执行destroy方法，Servlet对象会被销毁 destroy方法只执行一次 每次访问必定执行service方法，在service方法里写功能代码 3.3 域对象3.3.1 域对象 域对象：由Servlet规范提供的，能够临时存储数据的对象。在域对象的作用范围里可以共享数据。 API: 设置数据：setAttribute(String name, Object value) 获取数据：getAttribute(String name) 删除数据：removeAttribute(String name) 作用范围 3.3.2 ServletContextServletContext:Servlet上下文，当服务器软件启动时，服务器软件会把每个web项目抽象封装成一个ServletContext对象。一个web项目里，只有一个ServletContext对象 1ServletContext context = this.getServletContext(); SerletContext域对象 何时创建：服务器启动时 何时销毁：服务器关闭时 作用范围：整个web项目 3.3.3 request域对象 request域对象 何时创建：一次请求开始 何时销毁：一次请求结束 作用范围：一次请求中 3.3.4 cookie域对象 cookie域对象 何时创建：服务中new的 何时销毁：默认一次会话结束（关闭浏览器），可以手动设置有效期setMaxAge(int seconds) 作用范围：创建Cookie资源的上一级路径目录和目录下，可以手动设置有效范围cookie.setPath(String path) 3.3.5 session域对象session： 何时创建：一次会话开始 session不是一打开网站就会立刻建立。它的建立需要基于下面两个条件中的任意一个： 1：在servlet中手动调用 12HttpSession session = request.getSession();HttpSession session = request.getSession(true); 2：jsp中没有写&lt;%@ page session=”false”%&gt;，因为jsp会转成servlet,里面会默认创建session(默认情况下它是&lt;%@ page session=”true”%&gt;的) 如果两个条件同时都不满足，那么你建立的只是一个无seesion的连接。 何时销毁： 服务器(非正常)关闭，session销毁 会话超时，session自动销毁。默认30分钟，可以修改web.xml： 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 手动销毁：session.invalidate() 作用范围： 一次会话 在一次会话里（浏览器不关闭，不清除缓存），访问一个项目的任何资源，都可以共享数据 4. 会话在日常生活中，从拨通电话到挂断电话之间的一连串的你问我答的过程就是一个会话。Web应用中的会话过程类似于生活中的打电话过程，它指的是一个客户端（浏览器）与Web服务器之间连续发生的一系列请求和响应过程。 会话结束：浏览器关闭 Cookie: 把会话数据保存在客户端的技术 缺点：只能保存字符串，不够安全 优点：服务端压力小 session：把会话数据保存在服务端的技术 优点：安全性高，可以存储任意类型的数据 缺点：服务端压力大 4.1 CookieServlet规范限制：一个web项目最多给客户端20个Cookie，一个浏览器最多保存300个Cookie,每个Cookie最多4kb数据，但是各家浏览器不一样。 4.1.1 创建Cookie1Cookie cookie = new Cookie(String name,String value);//Cookie对象中只有名称和值，没有其他数据，只能是字符串 1. Cookie的有效期 默认有效期：一次会话期间（保存在浏览器内存中，浏览器不关闭） 手动设置有效期（保存到磁盘文件）：cookie.setMaxAge(int seconds) 2. Cookie的有效范围 浏览器自动携带Cookie：浏览器访问Cookie有效范围内的资源时，会自动携带Cookie数据到服务端。 默认有效范围：创建Cookie资源的上一级路径目录和目录下 123创建Cookie的资源是：http：//localhost/day41/createCookie默认有效范围是http：//localhost/day41 手动设置有效范围：cookie.setPath(String path) 1234创建Cookie的资源是：http://localhost/day41/aa/create手动设置有效范围cookie.setPath("/day41");//浏览器访问http://localhost/day41目录和目录下的所有资源都会自动携带该Cookie 4.1.2 发送Cookie到客户端1response.addCookie(cookie); 4.1.3 接受客户端携带来的Cookie123456Cookie[] cookies = request.getCookies();for循环//获取某cookie的名称String name = cookie.getName();//获取某cookie对象的值String value = cookie.getValue(); 4.1.4 服务端删除客户端的Cookie123456//删除客户端的名称为username，path是默认的有效范围：/day41 的CookieCookie cookie = new Cookie("username", "");cookie.setPath("/day41");cookie.setMaxAge(0);response.addCookie(cookie); 4.1.5 Cookie保存用户上一次登录时间123456789101112131415161718192021222324252627282930313233343536373839@WebServlet(name = "LoginServlet", urlPatterns = "/login")public class LoginServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //用户请求中的验证码获取 String code = request.getParameter("code"); //获取session中保存的验证码 String code_session = (String) request.getSession().getAttribute("code_session"); //与session中保存的验证码进行校验 if (!code_session.equalsIgnoreCase(code)) &#123; //验证码错误，告诉用户，页面提示 request.setAttribute("msg", "验证码错误"); request.getRequestDispatcher("/login.jsp").forward(request, response); return; &#125; //验证码正确，登录逻辑执行 //获取用户名和密码 String username = request.getParameter("username"); String password = request.getParameter("password"); //调用Service方法，登录用户 UserDao userDao = new UserDaoImpl(); User loginUser = userDao.login(username, password); if (loginUser == null) &#123; request.setAttribute("msg", "用户名或则密码错误"); request.getRequestDispatcher("/login.jsp").forward(request, response); return; &#125; else &#123; //登陆成功，跳转主页 response.sendRedirect(request.getContextPath()); return; &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 4.2 session当人们去医院就诊时，就诊病人需要办理医院的就诊卡，该卡上只有卡号，而没有其它信息。但病人每次去该医院就诊时，只要出示就诊卡，医务人员便可根据卡号查询到病人的就诊信息。Session技术就好比医院发放给病人的就医卡和医院为每个病人保留病例档案的过程。当浏览器访问Web服务器时，Servlet容器就会创建一个Session对象和ID属性，其中，Session对象就相当于病历档案，ID就相当于就诊卡号。当客户端后续访问服务器时，只要将标识号传递给服务器，服务器就能判断出该请求是哪个客户端发送的，从而选择与之对应的Session对象为其服务。需要注意的是，由于客户端需要接收、记录和回送Session对象的ID，因此，通常情况下，Session是借助Cookie技术来传递ID属性的。 4.2.1 创建和获取session1HttpSession session = request.getSession(); getSession()什么时候代表获取旧session对象： 客户端有JSESSIONID（Cookie的名称，Tomcat创建的Cookie） 并且 服务端有对应的session对象 getSession()什么时候代表创建新session对象： 客户端没有JSESSIONID 或者 服务端没有对应的session对象 4.2.2 session原理图 4.2.3 session存验证码 在验证码服务生成验证码，存到session中 123@WebServlet(name = "CheckcodeServlet",urlPatterns = "/checkcode")//生成验证码的服务// 将验证码放到session中request.getSession().setAttribute("code_session", code); 在登录服务对比客户传过来的验证码和session中是否一样12345@WebServlet(name = "LoginServlet",urlPatterns = "/login")//登录服务//用户请求中的验证码获取String code = request.getParameter("code");//获取session中保存的验证码String code_session = (String)request.getSession().getAttribute("code_session"); 4.2.4 关闭浏览器还能访问session数据(自定义JSESSIONID的Cookie) 创建一个servlet 通过request对象获取session的id 自定义一个cookie对象，保存session的id，注意cookie名称为”JSESSIONID”，设置一个比较长的生存时间 发送给浏览器 12345678//获取session对象HttpSession session = request.getSession();System.out.println(session);//自己创建一个cookie，要求被浏览器持久化保存起来（setMaxAge(10000)）放便后期使用Cookie cookie = new Cookie("JSESSIONID", session.getId());//活的久一点cookie.setMaxAge(10000);response.addCookie(cookie); 4.2.5 session的生命周期session： 何时创建：一次会话开始 何时销毁： 服务器(非正常)关闭，session销毁 会话超时，session自动销毁。默认30分钟，可以修改web.xml： 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 手动销毁：session.invalidate() 作用范围： 一次会话 在一次会话里（浏览器不关闭，不清除缓存），访问一个项目的任何资源，都可以共享数据 4.2.6 什么时候session数据可能会丢失？ 服务器非正常关闭，session已经销毁 浏览器关闭，没有JSSESSIONID的cookie 浏览器清除缓存（Cookie)，没有JSSESSIONID的cookie 换了浏览器访问，没有JSSESSIONID的cookie 4.3 cookie和session的区别 cookie和session的不同 cookie session 会话数据保存的位置 浏览器 服务器 数据安全性 不安全 安全 存储是否有限制 只能存字符串 存储任意的 java 对象 5. Filter5.1 什么是FilterFilter: 是Servlet规范提供的一种规范（接口）。作用在请求到达目标资源之前，Filter可以进行过滤处理，然后放行，请求才能达目标资源；作用在响应从服务器出发之前，Fliter可以进行过滤处理，然后放行，响应会到达客户端。 5.2 Filter的执行原理 浏览器发出请求 请求到达服务器软件，比如Tomcat Tomcat解析请求，请求行获取资源路径，请求头，请求体等，将浏览器请求封装成一个request对象，再初始化一个response对象 查找拦截请求资源的所有过滤器，封装到过滤器链中 执行过滤器链中的第一个过滤器，传参request和response Tomcat得到response对象，将response对象转换成HTTP响应，响应给浏览器 01.Filter的执行原理.png 5.3 filter的执行顺序 注解开发：按照filter类的全限定类名顺序 web.xml配置文件：&lt;filter-mapping&gt;标签出现的顺序 123456789&lt;!--配置Demo01的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;demo01&lt;/filter-name&gt; &lt;filter-class&gt;com.itheima.filter.Demo01QuickStartFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo01&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 5.4 filter解决中文乱码1234567891011121314151617@WebFilter("/*")... public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; //1.解决响应的中文乱码 response.setContentType("text/html;charset=utf-8"); //2.解决请求的中文乱码：post方式 String method = request.getMethod(); if ("POST".equalsIgnoreCase(method)) &#123; request.setCharacterEncoding("utf-8"); &#125; //3.放行请求 chain.doFilter(request, response); &#125; 5.5 filter解决敏感词汇过滤12345678910111213141516171819202122@WebFilter("/*")... public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; //1.接收提交的内容 String content = request.getParameter("content"); //2.判断是否为空，是否有敏感词。如果有敏感词，返回响应，不放行 if (content != null &amp;&amp; !"".equals(content)) &#123; for (String word : words) &#123; if (content.contains(word)) &#123; response.getWriter().print("包含敏感词，不要说脏话"); return; &#125; &#125; &#125; //3.如果可以放行，最后放行 chain.doFilter(request, response); &#125; 6. Listener6.1 什么是监听器监听器是一个专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。监听器其实就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。 监听器涉及三个组件：事件源，事件对象，事件监听器 当事件源发生某个动作的时候，它会调用事件监听器的方法，并在调用事件监听器方法的时候把事件对象传递进去。 我们在监听器中就可以通过事件对象获取得到事件源，从而对事件源进行操作！ 6.2 自定义普通类对象的监听器 在需要被监听的类里封装一个监听器，提供一个注册监听器的方法 在需要被监听的方法里调用监听器的方法，传参事件对象（事件对象里封装事件源） 在测试的时候注册监听器（监听器里得到事件，可以对事件源进行处理） 事件源执行被监听的方法后，触发监听器的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/*** @ClassName: Person(事件源)* @Description: 设计一个Person类作为事件源，这个类的对象的行为(比如吃饭、跑步)可以被其他的对象监听**/ public class Person &#123; /** * @Field: listener * 在Person类中定义一个PersonListener变量来记住传递进来的监听器 */ private PersonListener listener; /** * @Method: eat * @Description: 设计Person的行为：吃 * */ public void eat() &#123; if (listener != null) &#123; /** * 调用监听器的doeat方法监听Person类对象eat(吃)这个动作，将事件对象Event传递给doeat方法， * 事件对象封装了事件源，new Event(this)中的this代表的就是事件源 */ listener.doeat(new Event(this)); &#125; &#125; /** * @Method: run * @Description: 设计Person的行为：跑 * */ public void run() &#123; if (listener != null) &#123; /** * 调用监听器的dorun方法监听Person类对象run(跑)这个动作，将事件对象Event传递给doeat方法， * 事件对象封装了事件源，new Event(this)中的this代表的就是事件源 */ listener.dorun(new Event(this)); &#125; &#125; /** * @Method: registerListener * @Description: 这个方法是用来注册对Person类对象的行为进行监听的监听器 */ public void registerListener(PersonListener listener) &#123; this.listener = listener; &#125;&#125;/*** @ClassName: PersonListener(事件监听器)* @Description: 设计Person类(事件源)的监听器接口**/ interface PersonListener &#123; /** * @Method: doeat * @Description: 这个方法是用来监听Person对象eat(吃)这个行为动作， * 当实现类实现doeat方法时就可以监听到Person类对象eat(吃)这个动作 */ void doeat(Event e); /** * @Method: dorun * @Description: 这个方法是用来监听Person对象run(跑)这个行为动作， * 当实现类实现dorun方法时就可以监听到Person类对象run(跑)这个动作 */ void dorun(Event e);&#125;/*** @ClassName: Event(事件对象)* @Description:设计事件类，用来封装事件源*/ class Event &#123; /** * @Field: source * 事件源(Person就是事件源) */ private Person source; public Event() &#123; &#125; public Event(Person source) &#123; this.source = source; &#125; public Person getSource() &#123; return source; &#125; public void setSource(Person source) &#123; this.source = source; &#125;&#125; 12345678910111213141516171819202122232425262728public class PersonTest &#123; /** * @Description: 测试Person类 */ public static void main(String[] args) &#123; // Person p = new Person(); //注册监听p对象行为的监听器 p.registerListener(new PersonListener() &#123; //监听p吃东西这个行为 public void doeat(Event e) &#123; Person p = e.getSource(); System.out.println(p + "在吃东西"); &#125; //监听p跑步这个行为 public void dorun(Event e) &#123; Person p = e.getSource(); System.out.println(p + "在跑步"); &#125; &#125;); //p在吃东西 p.eat(); //p在跑步 p.run(); &#125;&#125; 6.3 Servlet监听器在Servlet规范中定义了多种类型的监听器，它们用于监听的事件源分别 ServletContext, HttpSession和ServletRequest这三个域对象 6.3.1 servlet监听器分类按被监听的对象划分：ServletRequest域 HttpSession域 ServletContext域 按监听的内容分：监听域对象的创建与销毁的(init，destroy) 监听域对象的属性变化的（其他方法setAttribute等） session绑定对象相关的监听器： 绑定与解绑的监听器HttpSessionBindingListener 钝化与活化的监听器HttpSessionActivationListener 绑定状态：就一个对象被放到session域中 解绑状态：就是这个对象从session域中移除了 钝化状态：是将session内存中的对象持久化（序列化）到磁盘 活化状态：就是将磁盘上的对象再次恢复到session内存中 6.3.2 共8个servlet监听器监听域对象的创建与销毁的六个servlet监听器和session绑定对象相关的2个监听器，共8个servlet监听器 ServletContext域 HttpSession域 ServletRequest域 域对象的创建与销毁 ServletContextListener HttpSessionListener ServletRequestListener 域对象内的属性变化 ServletContextAttributeListener HttpSessionAttributeListener ServletRequestAttributeListener 绑定与解绑 HttpSessionBindingListener 钝化与活化 HttpSessionActivationListener 6.3.3 监听域对象的创建与销毁的listener举例123456789101112131415161718192021import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;/*** @ClassName: MyServletContextListener* @Description: MyServletContextListener类实现了ServletContextListener接口，* 因此可以对ServletContext对象的创建和销毁这两个动作进行监听。*/ public class MyServletContextListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println("ServletContext对象创建"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println("ServletContext对象销毁"); &#125;&#125; 1234567891011&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app&gt; &lt;!-- 注册针对ServletContext对象进行监听的监听器 --&gt; &lt;listener&gt; &lt;description&gt;ServletContextListener监听器&lt;/description&gt; &lt;!--实现了ServletContextListener接口的监听器类 --&gt; &lt;listener-class&gt;me.gacl.web.listener.MyServletContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;/web-app&gt; 6.3.4 session绑定对象相关的监听器举例1234567&lt;Context&gt; &lt;!-- maxIdleSwap:session中的对象多长时间不使用就钝化 --&gt; &lt;!-- directory:钝化后的对象的文件写到磁盘的哪个目录下--&gt; &lt;Manager className="org.apache.catalina.session.PersistentManager" maxIdleSwap="1"&gt;// &lt;Store className="org.apache.catalina.session.FileStore" directory="zhongfucheng"/&gt; &lt;/Manager&gt;&lt;/Context&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** 由于涉及到了将内存的Session钝化到硬盘和用硬盘活化到内存中，所以需要实现Serializable接口** 该监听器是不需要在web.xml文件中配置的。但监听器要在事件源上实现接口* 也就是说，直接用一个类实现HttpSessionBindingListener和HttpSessionActivationListener接口是监听不到Session内对象的变化的。* 因为它们是感知自己在Session中的变化！* */public class User implements HttpSessionBindingListener,HttpSessionActivationListener,Serializable &#123; private String username ; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; @Override public void sessionWillPassivate(HttpSessionEvent httpSessionEvent) &#123; HttpSession httpSession = httpSessionEvent.getSession(); System.out.println("钝化了"); &#125; @Override public void sessionDidActivate(HttpSessionEvent httpSessionEvent) &#123; HttpSession httpSession = httpSessionEvent.getSession(); System.out.println("活化了"); &#125; @Override public void valueBound(HttpSessionBindingEvent httpSessionBindingEvent) &#123; System.out.println("绑定了对象"); &#125; @Override public void valueUnbound(HttpSessionBindingEvent httpSessionBindingEvent) &#123; System.out.println("解除了对象"); &#125;&#125; 123User user = new User();request.getSession().setAttribute("aaa", user);request.getSession().removeAttribute("aaa"); 6.3.5 监听器统计在线人数–HttpSessionListener实现12345678910111213141516171819202122232425package com.pb.news.web.servlet;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class UserCountListener implements HttpSessionListener &#123; private int count = 0; public void sessionCreated(HttpSessionEvent se) &#123; //人数加1 count++; setContext(se); &#125; public void sessionDestroyed(HttpSessionEvent se) &#123; //人数减1 count--; setContext(se); &#125; private void setContext(HttpSessionEvent se)&#123; se.getSession().getServletContext().setAttribute("userCount",new Integer(count)); &#125;&#125; 12345678创建UserCountListener监听器，注意web.xml中要有：&lt;listener&gt; &lt;listener-class&gt;com.pb.news.web.servlet.UserCountListener&lt;/listener-class&gt;&lt;/listener&gt;创建监听器后，可以在需要显示人数的页面加入下面的语句：Object userCount=session.getServletContext().getAttribute("userCount");out.print(userCount.toString()); 7. InterceptorSpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会按着定义的顺序执行。拦截器也是AOP思想的一种实现方式。想要自定义拦截器，需要实现HandlerInterceptor接口。 7.1自定义拦截器7.1.1创建类，实现HandlerInterceptor接口，重写需要的方法123456789101112131415161718/*** 自定义拦截器*/public class MyInterceptor1 implements HandlerInterceptor&#123; /** * controller方法执行前，进行拦截的方法 * return true放行 * return false拦截 * 可以使用转发或者重定向直接跳转到指定的页面。 */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("拦截器执行了..."); return true; &#125;&#125; 7.1.2 在springmvc.xml中配置拦截器类123456789101112&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 哪些方法进行拦截 --&gt; &lt;mvc:mapping path="/user/*"/&gt; &lt;!-- 哪些方法不进行拦截 &lt;mvc:exclude-mapping path=""/&gt; --&gt; &lt;!-- 注册拦截器对象 --&gt; &lt;bean class="com.itheima.demo1.MyInterceptor1"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 8. 过滤器和拦截器的执行顺序图 9. 过滤器、拦截器、监听器9.1 过滤器： 依赖于servlet容器； 在实现上基于函数回调，可以对几乎所有请求进行过滤； 缺点是一个过滤器实例只能在容器初始化时调用一次； 使用过滤器的目的是用来做一些过滤操作，获取我们想要获取的数据，比如：在过滤器中修改字符编码；在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等。 9.2 拦截器： 依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架； 在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用； 缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理； 由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。 9.3 监听器 实现了javax.servlet.ServletContextListener 接口的服务器端程序； 随web应用的启动而启动； 只初始化一次； 随web应用的停止而销毁； 主要作用是： 做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。如SpringMVC的监听器org.springframework.web.context.ContextLoaderListener，实现了SpringMVC容器的加载、Bean对象创建、DispatchServlet初始化等。 10. 过滤器和拦截器的区别 过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术；拦截器是SpringMVC框架独有的。 过滤器配置了/*，可以拦截任何资源；拦截器只会对控制器中的方法进行拦截。 拦截器是基于java的反射机制的，而过滤器是基于函数回调。 拦截器不依赖与servlet容器，过滤器依赖与servlet容器。 执行顺序不一样，过滤器是在请求进入servlet前和响应之前，拦截器是请求进入DispatchServlet后，然后由处理器映射器包装进执行链。 拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令三部曲]]></title>
    <url>%2Fgit%2Fgit%E5%91%BD%E4%BB%A4%E4%B8%89%E9%83%A8%E6%9B%B2%2F</url>
    <content type="text"><![CDATA[git add . //管理当前目录下所有的文件，忽略文件除外 git commit -m “上传本地代码至远程仓库” 将本地代码推送到远程仓库，使用如下命令： git push]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins持续集成]]></title>
    <url>%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2Fjenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[jenkins持续集成Jenkins持续集成 它是一个自动化的周期性的集成测试过程 保证团队开发人员提交代码的质量，减轻了软件发布时的压力]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot打包与微服务部署]]></title>
    <url>%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2Fspringboot%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[springboot打包与微服务部署微服务部署有两种方法： （1）手动部署：首先基于源码打包生成jar包（或war包）,将jar包（或war包）上传至虚拟机并拷贝至JDK容器。 （2）通过Maven插件自动部署。（常用，和手动部署原理一致） 1. 手动部署1. 将源码打包生成jar包SpringBoot打包 pom.xml添加 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- Spring Boot的启动类--&gt; &lt;mainClass&gt;com.tensquare.eureka.EurekaApplication&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 在启动类添加 extends SpringBootServletInitializer 在启动类中重写配置@Override protected SpringApplicationBuilder configure( SpringApplicationBuilder builder) { return builder.sources(this.getClass()); } clean, package java -jar 打成包的文件名(因为Windows配置了jdk的环境变量，在Windows直接就可以跑起来了，在docker中，需要在jdk镜像基础上打包微服务镜像，下面是在docker中部署微服务的步骤) 2. 使用脚本创建jdk镜像步骤： （1）创建目录 1mkdir –p /usr/local/java （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/java目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t=&apos;jdk1.8&apos; . （5）查看镜像是否建立完成 1docker images （6）创建容器 1docker run -it --name=myjdk8 jdk1.8 /bin/bash 3. 使用Dockerfile在jdk镜像上创建微服务镜像123456789101112131415# 基于哪个镜像FROM java:8# 将本地文件夹挂载到当前容器VOLUME /tmp# 拷贝文件到容器，也可以直接写成ADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar /app.jarADD microservice-discovery-eureka-0.0.1-SNAPSHOT.jar app.jarRUN bash -c &apos;touch /app.jar&apos;# 开放8761端口EXPOSE 8761# 配置容器启动后执行的命令ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 4. 将微服务镜像run成容器即可2. 通过Maven插件自动部署Maven插件自动部署步骤： （1）修改宿主机的docker配置，让其可以远程访问1vi /lib/systemd/system/docker.service 其中ExecStart=后添加配置-H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock （2）刷新配置，重启服务123456#刷新配置systemctl daemon-reload#重启dockersystemctl restart docker#重启私有仓库docker start registry （3）在tensquare_eureka工程pom.xml 增加配置12345678910111213141516171819202122232425262728 &lt;build&gt; &lt;finalName&gt;app&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- docker的maven插件，官网：https://github.com/spotify/docker-maven-plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;192.168.184.135:5000/$&#123;project.artifactId&#125;:$&#123;project.version&#125;&lt;/imageName&gt; &lt;baseImage&gt;jdk1.8&lt;/baseImage&gt; &lt;entryPoint&gt;["java", "-jar", "/$&#123;project.build.finalName&#125;.jar"]&lt;/entryPoint&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;dockerHost&gt;http://192.168.184.135:2375&lt;/dockerHost&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 以上配置会自动生成Dockerfile 123FROM jdk1.8ADD app.jar /ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] （4）在windows的命令提示符下，进入tensquare_eureka工程所在的目录，输入以下命令，进行打包和上传镜像1234mvn clean package docker:build -DpushImage#跳过测试-DskipTests]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合面试]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2F%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[集合面试集合分为单列集合和双列集合 单列集合单列集合的顶级接口是Collection,下面有两个接口List和Set，List接口下集合的特点是有序，可重复； Set接口下集合：无序，不可重复 双列集合 集合总结图 面试题1. 集合的线程安全安全的集合有Vector和HashTable, 线程不安全ArrayList、HashSet、HashMap可以通过Collections类方法转化成线程安全的集合，其实就是在方法上加synchronized 1234561. // Collections.synchronizedCollection(c)2. // Collections.synchronizedList(list)3. // Collections.synchronizedMap(m)4. // Collections.synchronizedSet(s) List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(list1); 2. 并发集合按时并发集合 是jdk5.0重要的特性，增加了并发包java.util.concurrent.*。Java内存模型、volatile变量及AbstractQueuedSynchronizer(简称AQS同步器)，是并发包众多实现的基础。 常见的并发集合： ConcurrentHashMap：线程安全的HashMap的实现CopyOnWriteArrayList：线程安全且在读操作时无锁的ArrayListCopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素ArrayBlockingQueue：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue CopyOnWrite集合即写时复制的集合。 通俗的理解是当我们往一个集合添加元素的时候，不直接往当前集合添加，而是先将当前集合进行Copy，复制出一个新的集合，然后新的集合里添加元素，添加完元素之后，再将原集合的引用指向新的集合。这样做的好处是我们可以对CopyOnWrite集合进行并发的读，而不需要加锁，因为当前集合不会添加任何元素。所以CopyOnWrite集合也是一种读写分离的思想，读和写不同的集合。 Synchronized vs Concurrent Collections 不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在性能和可扩展性，还有他们如何实现的线程安全。同步HashMap, Hashtable, HashSet, Vector, ArrayList 相比他们并发的实现（比如：ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet）会慢得多。造成如此慢的主要原因是锁， 同步集合会把整个Map或List锁起来，而并发集合不会。并发集合实现线程安全是通过使用先进的和成熟的技术像锁剥离。比如ConcurrentHashMap 会把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段。锁仅用于 put 和 remove 等改变集合对象的操作，基于 volatile 及 HashEntry 链表的不变性实现了读取的不加锁。 这些方式使得 ConcurrentHashMap 能够保持极好的并发支持， 尤其是对于读远比插入和删除频繁的 Map而言， 同样的，CopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个List复制一个副本给它。 如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。 3. List 的三个子类的特点复杂度有时间复杂度和空间复杂度： 一个有 1000 个元素的 LinkedList 对象将有 1000 个链接在一起 的 Entry 对象； ArrayList 使用一个内置的数组来存 储元素，这个数组的起始容量是 10.当数组需要增长时，容量大概会增长 50%。 这就意味着，如果你有一个包含大量元素的 ArrayList 对象，那么最终将有很大的空间会被浪费掉，如果我们知道一个 ArrayList 将会有多少个元素，我们可以通过构造方法来指定容量。我们还可以通过 trimToSize 方法在 ArrayList 分配完毕之后去掉浪 费掉的空间。 总结：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList 会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用 LinkedList 了。 ArrayList 底层结构是数组,查询快,增删慢。如果只是用add方法的话，速度也可以，因为是在数组最后追加或删除元素，只会因为数组长度不够扩容影响速度。但是如果不是在最后追加或删除的话，插入元素后面的元素索引都会改变，速度慢。因为有索引，查找快。 LinkedList 底层结构是双向链表,增删快,查询慢。在LinkedList集合中的每个人都是随便站的。但是他们中的每个人都认识一个人。并且每两个认识的人之间都有一个链子把他们连接起来。所有人都连接完之后，顺着链子看，就也有一个顺序，每个人就也有一个序号，但是这个序号并没有标出来。也就是说相当于有一个隐式的序号。所以：比如我要叫4号出来的时候，他们并不知道自己到底谁是4号，所以就要顺着链子从头开始查一下，查到4号是谁了，4号就出来了。也就是说，每次要找n号位置的人时，都要从头查一遍，看谁是n号。所以查找比较麻烦。至于增删效率高，就很容易理解了。 indexof 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647LinkedList&lt;Integer&gt; integerLinkedList = new LinkedList&lt;&gt;(); integerLinkedList.add(1); integerLinkedList.add(2); integerLinkedList.add(3); integerLinkedList.add(4); Integer i = integerLinkedList.indexOf(2);//元素为2的索引 integerLinkedList.get(1);//取到索引为1的元素 System.out.println(i);public int indexOf(Object o) &#123; int index = 0;//索引是自己从链的头开始计数的 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; voctor 底层结构是数组 线程安全的,增删慢,查询慢。 4. Collections集合工具类 java.utils.Collections是集合工具类，操作的对象是集合。部分方法使用如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往传入集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list):随机置换,即可以打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序,整数从小到大排序 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; c):将集合中元素按照指定规则排序。 123456789101112List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("cba"); list.add("aba"); list.add("sba"); list.add("nba"); Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.charAt(0)-o1.charAt(0);//o2--o1降序；o1--o2升序 &#125; &#125;); System.out.println(list); 简述Comparable可比较接口和Comparator比较器接口的区别说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候再去选择的java.util.Comparator接口完成。 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用 Comparable：类内部实现比较器,默认规则 Comparator: 外比较器,类的外部自己写规则 //记忆,不管是内比较器还是外比较器,只要排序都要实现这两个接口之一, 如果两个接口都实现,优先考虑的外比较器Comparator 5. 为什么要用 List list = new ArrayList() ,而不用 ArrayList alist = new ArrayList()呢？多态的好处： 问题就在于List有多个实现类，现在你用的是ArrayList，也许哪一天你需要换成其它的实现类，如 LinkedList或者Vector等等，这时你只要改变这一行就行了： List list = new LinkedList(); 其它使用了list地方的代码根本不需要改动。 假设你开始用 ArrayList alist = new ArrayList(), 这下你有的改了，特别是如果你使用了 ArrayList特有的方法和属性。 List a=new ArrayList()和 ArrayList a =new ArrayList()的区别？ List list = new ArrayList();这句创建了一个 ArrayList 的对象后把上溯到了 List。此时它是一个 List 对象了，有些ArrayList 有但是 List 没有的属性和方法，它就不能再用了。而 ArrayList list=new ArrayList();创建一对象则保留了ArrayList 的所有属性。 所以需要用到 ArrayList 独有的方法的时候不能用前者。实例代码如下： 12341．List list = new ArrayList();2．ArrayList arrayList = new ArrayList();3．list.trimToSize(); //错误，没有该方法。4．arrayList.trimToSize(); //ArrayList 里有该方法。 6. 字符串去重排序12345678910111213141516171819202122232425262728//字符串去重并排序public static String RdSort(String str)&#123; String[] strs = str.split(""); TreeSet&lt;String&gt; stringTreeSet = new TreeSet&lt;&gt;();//使用TreeSet元素排序并去重的原理 for (String s : strs) &#123; stringTreeSet.add(s); &#125; System.out.println(stringTreeSet); String stryes=""; for (String s : stringTreeSet) &#123; stryes+=s; &#125; return stryes; &#125;//字符串去重并保持原来顺序public static String rd(String str)&#123; String[] strs = str.split(""); LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();//利用LinkedHashSet for (String s : strs) &#123; linkedHashSet.add(s); &#125; System.out.println(linkedHashSet); String stryes=""; for (String s : linkedHashSet) &#123; stryes+=s; &#125; return stryes; &#125; 7. HashMap和Hashtable的键值分别能为null吗？1234567891011121314151617181920212223 public static void main(String[] args) &#123; Map map=new HashMap(); map.put(null,null);//HashMap的键值都可以为NUll System.out.println(map.get(null)); Map htmap = new Hashtable();//Hashtable的键值都不能为null htmap.put("a",null); htmap.get("a"); &#125;//HashMap源码 static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);//键为空时返回0 &#125;//Hashtable源码 public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException();//值为null时，抛空指针异常 &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode();//键为null时，抛空指针异常]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试，集合</tag>
      </tags>
  </entry>
</search>
