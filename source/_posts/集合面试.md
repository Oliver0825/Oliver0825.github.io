---
title: 集合面试
date: 2019-06-10 20:00:24
tags: [面试，集合]
category: 面试
---

# 集合面试

集合分为单列集合和双列集合

### 单列集合

单列集合的顶级接口是Collection,下面有两个接口List和Set，List接口下集合的特点是有序，可重复；

Set接口下集合：无序，不可重复

 {% asset_img Collection集合体系图.png %}

![](集合面试\Collection集合体系图.png)

### 双列集合



{% asset_img map集合体系.png %}

![](集合面试\map集合体系.png)

### 集合总结图

{% asset_img 集合体系总结.png %}

![](集合面试\集合体系总结.png)

### 面试题

#### 1. 集合的线程安全

安全的集合有Vector和HashTable, 线程不安全ArrayList、HashSet、HashMap可以通过Collections类方法转化成线程安全的集合，其实就是在方法上加synchronized

```java
1. //  Collections.synchronizedCollection(c)
2. //  Collections.synchronizedList(list)
3. //  Collections.synchronizedMap(m)
4. //  Collections.synchronizedSet(s)
 List<Integer> list1 = new ArrayList<>();
 List<Integer> synchronizedList = Collections.synchronizedList(list1);
```

####  2. 并发集合

按时并发集合 是jdk5.0重要的特性，增加了并发包java.util.concurrent.*。Java内存模型、volatile变量及AbstractQueuedSynchronizer(简称AQS同步器)，是并发包众多实现的基础。

**常见的并发集合**： 
**ConcurrentHashMap**：线程安全的HashMap的实现 
**CopyOnWriteArrayList**：线程安全且在读操作时无锁的ArrayList 
CopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素 
ArrayBlockingQueue：基于数组、先进先出、线程安全，可实现指定时间的阻塞读写，并且容量可以限制 
LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作都多的情况下，性能优于ArrayBlockingQueue

**CopyOnWrite集合即写时复制的集合。** 

通俗的理解是当我们往一个集合添加元素的时候，不直接往当前集合添加，而是先将当前集合进行Copy，复制出一个新的集合，然后新的集合里添加元素，添加完元素之后，再将原集合的引用指向新的集合。这样做的好处是我们可以对CopyOnWrite集合进行并发的读，而不需要加锁，因为当前集合不会添加任何元素。所以CopyOnWrite集合也是一种读写分离的思想，读和写不同的集合。

**Synchronized vs Concurrent Collections**

不管是同步集合还是并发集合他们都支持线程安全，他们之间主要的区别体现在**性能**和**可扩展性**，还有他们如何实现的线程安全。同步HashMap, Hashtable, HashSet, Vector, ArrayList 相比他们并发的实现（比如：ConcurrentHashMap, CopyOnWriteArrayList, CopyOnWriteHashSet）会慢得多。造成如此慢的主要原因是**锁**， **同步集合会把整个Map或List锁起来**，而并发集合不会。并发集合实现线程安全是通过使用先进的和成熟的技术像锁剥离。比如**ConcurrentHashMap 会把整个Map 划分成几个片段，只对相关的几个片段上锁，同时允许多线程访问其他未上锁的片段**。锁仅用于 put 和 remove 等改变集合对象的操作，基于 volatile 及 HashEntry 链表的不变性实现了**读取的不加锁**。 这些方式使得 ConcurrentHashMap 能够保持极好的并发支持， 尤其是对于读远比插入和删除频繁的 Map
而言，

同样的，CopyOnWriteArrayList 允许多个线程以非同步的方式读，当有线程写的时候它会将整个List复制一个副本给它。

如果在读多写少这种对并发集合有利的条件下使用并发集合，这会比使用同步集合更具有可伸缩性。

#### 3. List 的三个子类的特点

复杂度有时间复杂度和空间复杂度：

一个有 1000 个元素的 LinkedList 对象将有 1000 个链接在一起 的 Entry 对象；

ArrayList 使用一个内置的数组来存 储元素，这个数组的起始容量是 10.当数组需要增长时，容量大概会增长 50%。 这就意味着，如果你有一个包含大量元素的 ArrayList 对象，那么最终将有很大的空间会被浪费掉，如果我们知道一个 ArrayList 将会有多少个元素，我们可以通过**构造方法来指定容量**。我们还可以通过 **trimToSize** 方法在 ArrayList 分配完毕之后去掉浪 费掉的空间。

***总结：***当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList 会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用 LinkedList 了。

{% asset_img ArrayList和linkedlist效率.png %}

![](集合面试\ArrayList和linkedlist效率.png)



1. ArrayList 底层结构是数组,查询快,增删慢。如果只是用add方法的话，速度也可以，因为是在数组最后追加或删除元素，只会因为数组长度不够扩容影响速度。但是如果不是在最后追加或删除的话，插入元素后面的元素索引都会改变，速度慢。因为有索引，查找快。

2. LinkedList 底层结构是双向链表,增删快,查询慢。在LinkedList集合中的每个人都是随便站的。但是他们中的每个人都认识一个人。并且每两个认识的人之间都有一个链子把他们连接起来。所有人都连接完之后，**顺着链子看，就也有一个顺序，每个人就也有一个序号，但是这个序号并没有标出来**。也就是说相当于有一个隐式的序号。所以：比如我要叫4号出来的时候，他们并不知道自己到底谁是4号，所以就要顺着链子从头开始查一下，查到4号是谁了，4号就出来了。也就是说，每次要找n号位置的人时，都要从头查一遍，看谁是n号。所以查找比较麻烦。至于增删效率高，就很容易理解了。 indexof

   ```java
   LinkedList<Integer> integerLinkedList = new LinkedList<>();
           integerLinkedList.add(1);
           integerLinkedList.add(2);
           integerLinkedList.add(3);
           integerLinkedList.add(4);
           Integer i = integerLinkedList.indexOf(2);//元素为2的索引
           integerLinkedList.get(1);//取到索引为1的元素
           System.out.println(i);
   
   public int indexOf(Object o) {
           int index = 0;//索引是自己从链的头开始计数的
           if (o == null) {
               for (Node<E> x = first; x != null; x = x.next) {
                   if (x.item == null)
                       return index;
                   index++;
               }
           } else {
               for (Node<E> x = first; x != null; x = x.next) {
                   if (o.equals(x.item))
                       return index;
                   index++;
               }
           }
           return -1;
       }
   
   public E get(int index) {
           checkElementIndex(index);
           return node(index).item;
       }
   
    Node<E> node(int index) {
           // assert isElementIndex(index);
   
           if (index < (size >> 1)) {
               Node<E> x = first;
               for (int i = 0; i < index; i++)
                   x = x.next;
               return x;
           } else {
               Node<E> x = last;
               for (int i = size - 1; i > index; i--)
                   x = x.prev;
               return x;
           }
       }
   ```

   

3. voctor 底层结构是数组 线程安全的,增删慢,查询慢。

   

#### 4. Collections集合工具类

- `java.utils.Collections`是集合工具类，操作的对象是集合。部分方法使用如下：

- `public static <T> boolean addAll(Collection<T> c, T... elements)  `:往传入集合中添加一些元素。

- `public static void shuffle(List<?> list) `:随机置换,即可以打乱集合顺序。

- `public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序,整数从小到大排序

- `public static <T> void sort(List<T> list，Comparator<? super T> c)`:将集合中元素按照指定规则排序。

  ```java
  List<String> list = new ArrayList<>();
          list.add("cba");
          list.add("aba");
          list.add("sba");
          list.add("nba");
          Collections.sort(list, new Comparator<String>() {
              @Override
              public int compare(String o1, String o2) {
                  return o2.charAt(0)-o1.charAt(0);//o2--o1降序；o1--o2升序
              }
          });
          System.out.println(list);
  ```

  ## 简述Comparable可比较接口和Comparator比较器接口的区别

  说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用`java.lang.Comparable`接口去实现，一种是灵活的当我需要做排序的时候再去选择的`java.util.Comparator`接口完成。

  那么我们采用的`public static <T> void sort(List<T> list)`这个方法完成的排序，实际上**要求了被排序的类型需要实现Comparable接口**完成比较的功能，在String类型上如下：

  ```java
  public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
  ```

  String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用

  **Comparable**：类内部实现比较器,默认规则

  **Comparator**: 外比较器,类的外部自己写规则

  //**记忆,不管是内比较器还是外比较器,只要排序都要实现这两个接口之一,**

  **如果两个接口都实现,优先考虑的外比较器Comparator**

#### 5. **为什么要用 List list = new ArrayList() ,而不用 ArrayList alist = new ArrayList()呢？** 

多态的好处： 问题就在于List有多个实现类，现在你用的是ArrayList，也许哪一天你需要换成其它的实现类，如 LinkedList或者Vector等等，这时你只要改变这一行就行了：  List list = new LinkedList(); 其它使用了list地方的代码根本不需要改动。  假设你开始用 ArrayList alist = new ArrayList(), 这下你有的改了，特别是如果你使用了 ArrayList特有的方法和属性。 

List a=new ArrayList()和 ArrayList a =new ArrayList()的区别？

List list = new ArrayList();这句创建了一个 ArrayList 的对象后把上溯到了 List。此时它是一个 List 对象了，有些
ArrayList 有但是 List 没有的属性和方法，它就不能再用了。而 ArrayList list=new ArrayList();创建一对象则保留了
ArrayList 的所有属性。 所以需要用到 ArrayList 独有的方法的时候不能用前者。实例代码如下：

```java
1．List list = new ArrayList();
2．ArrayList arrayList = new ArrayList();
3．list.trimToSize(); //错误，没有该方法。
4．arrayList.trimToSize(); //ArrayList 里有该方法。
```



#### 2.  字符串去重排序

```java
//字符串去重并排序
public static String RdSort(String str){
        String[] strs = str.split("");
        TreeSet<String> stringTreeSet = new TreeSet<>();//使用TreeSet元素排序并去重的原理
        for (String s : strs) {
            stringTreeSet.add(s);
        }
        System.out.println(stringTreeSet);
        String stryes="";
        for (String s : stringTreeSet) {
            stryes+=s;
        }
        return stryes;
    }
//字符串去重并保持原来顺序
public static String rd(String str){
        String[] strs = str.split("");
        LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();//利用LinkedHashSet
        for (String s : strs) {
            linkedHashSet.add(s);
        }
        System.out.println(linkedHashSet);
        String stryes="";
        for (String s : linkedHashSet) {
            stryes+=s;
        }
        return stryes;
    }
```

